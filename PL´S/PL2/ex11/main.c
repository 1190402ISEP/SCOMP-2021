/*11. Write a program that creates 5 child processes. Connect all 6 processes with a “ring” topology through pipes: the
*parent process will be connected to child 1, child 1 is connected to child 2, ..., and child 5 is connected to the parent
*process. The goal is to find the greatest random number generated by all processes:
*
*a.Each process generates a random number between 1 and 500. Then, it prints it along with its PID;
*b. Then, the parent process sends its generated number to child 1;
*c.Child 1 compares the parent’s number with its own random number and sends the greater of the two to child 2;
*d. All other processes follow the same behavior, until child 5 sends the greater number to the parent process;
*e.The parent process prints the greatest random number.
*/
#include <sys/wait.h>
#include <time.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>

int main(void)
{
    const int LEITURA = 0;
    const int ESCRITA = 1;

    const int NUMERO_DE_PROCESSOS_FILHOS = 5;

    //NUMERO_DE_PROCESSOS_FILHOS+1
    const int NUMERO_DE_PIPES = 6;

    int fd[NUMERO_DE_PIPES][2];

    int i;

    for (i = 0; i < NUMERO_DE_PIPES; i++)
    { //Criar Pipes
        if (pipe(fd[i]) == -1)
        {
            perror("Pipe failed");
            return 1;
        }
    }

    pid_t pid;

    int buffer = 0;

    int numeroAleatorio = 0; //número aleatório que será usado nas comparações

    for (i = 0; i < NUMERO_DE_PROCESSOS_FILHOS; i++)
    { //Criar processos Filho

        pid = fork(); //Fork cria um processo filho

        if (pid == -1)
        {
            perror("Fork Failed");
            exit(EXIT_FAILURE);
        }
        if (pid == 0)
        {

            srand((unsigned)time(NULL) * getpid());

            close(fd[i][ESCRITA]);
            read(fd[i][LEITURA], &buffer, sizeof(int));

            numeroAleatorio = rand() % (1 + 500) + 1;

            printf("PID: %d, Número: %d\n", getpid(), numeroAleatorio);

            close(fd[i][LEITURA]);

            close(fd[i + 1][LEITURA]);

            //verificar qual o maior valor e passar ao pipe que liga os childs seguintes
            if (numeroAleatorio > buffer)
            {
                write(fd[i + 1][ESCRITA], &numeroAleatorio, sizeof(int));
            }
            else
            {
                write(fd[i + 1][ESCRITA], &buffer, sizeof(int));
            }
            close(fd[i + 1][ESCRITA]);
            exit(EXIT_SUCCESS);
        }
    }

    srand((unsigned)time(NULL) * getpid());

    numeroAleatorio = rand() % (1 + 500) + 1; //gerar nº aleatório

    printf("PID: %d, Número: %d\n", getpid(), numeroAleatorio);

    close(fd[0][LEITURA]);

    write(fd[0][ESCRITA], &numeroAleatorio, sizeof(int));

    close(fd[0][ESCRITA]);

    close(fd[5][ESCRITA]);

    read(fd[5][LEITURA], &numeroAleatorio, sizeof(int));
    close(fd[5][LEITURA]);

    printf("Maior número: %d\n", numeroAleatorio);

    return 0;
}